---
title: "exercise-04"
output: html_document
date: "2024-02-12"
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# other code chunk options: 
# echo
# eval
# message
# include
# fig-height
# out-width
```

Instructions: <https://difiore.github.io/ada-2024/exercise-04.html>

## Wordle Program

Preliminaries

-   Set up a new ***GitHub*** repo - "exercise-04" and clone that down to computer as a new ***RStudio*** project. Add Tony as a collaborator (my ***GitHub*** username is "difiore").

-   DONE: Go to <https://github.com/difiore/ada-2024-datasets>, download the following two data files, and add them to your repo:

    -   collins-scrabble-words-2019.txt (list of official scrabble words)

    -   google-10000-english-usa-no-swears.txt (\~10,000 most common english words)

```{r download}
library(tidyverse)

# read in txt files
read_tsv("https://raw.githubusercontent.com/difiore/ada-2024-datasets/main/google-10000-english-usa-no-swears.txt", col_names = TRUE)
read_tsv("https://raw.githubusercontent.com/difiore/ada-2024-datasets/main/collins-scrabble-words-2019.txt", col_names = TRUE)

scrabble_wrds <- "https://raw.githubusercontent.com/difiore/ada-2024-datasets/main/google-10000-english-usa-no-swears.txt"
google_words <- "https://raw.githubusercontent.com/difiore/ada-2024-datasets/main/collins-scrabble-words-2019.txt"
```

## **Step 1:** Create load_dictionary() function & word lists

```{r load_dictionary fxn}
load_dictionary <- function(filename) {
  unlist(as.vector(read_tsv(filename, col_names = TRUE)))}

  #unname(unlist(read.table("temp.tsv", sep="\t")))

# create solution_list (possible solution words) and valid_list (valid words to guess)
solution_list <- load_dictionary(scrabble_wrds)
valid_list <- load_dictionary(google_words)

# Running str(valid_list) should return… [chr [1:279496] "AA" "AAH" "AAHED" "AAHING"...]
str(valid_list) # looks good

# Running str(solution_list) should return…[chr [1:8336] "THE" "OF" "AND" "TO"...]
str(solution_list) # looks good
```

## **Step 2: Winnow solution_list to only include valid words**

```{r winnow_lists}
#doesn't work if I load in as vector...
solution_list <- intersect(solution_list, valid_list)
# 8336 words
```

## **Step 3: Write pick_solution() fxn**

```{r pick_sol_fxn, warning = FALSE}
#pass in solution_list_
pick_solution <- function(solution_list, word_length = 5) {
  #rm(solution)
  five_letter_words <- subset(solution_list, nchar(solution_list) == word_length) # create subset of 5-letter words
  solution <- sample(five_letter_words, 1, replace = FALSE) # choose random word from subset
  solution_char <- str_split_1(solution, "") # splits random word into vector of characters   
  return(solution_char)
}
solution <- pick_solution(solution_list)
```

#### **Step 4: Create play_wordle() and evaluate_guess() fxns**

Create two more functions:

1.  `play_wordle()` : should take three arguments:
    1.  Answer to the puzzle (the value of your **solution** variable),
    2.  A list of valid guesses (the contents of your **valid_list** variable)
    3.  alue for "number of guesses", which you should set to the original **Wordle** game default of 6.

```{r packages}
install.packages("tibble")
library(tibble)
library(tidyverse)
```

```{r play_wordle}
play_wordle <- function(solution, valid_list, num_guesses=6) {} # adjust brackets once done
  
  # initialize nested evaluate_guess sub-fxn to determine if guess is valid 
  guess <- ("") # initialize empty guess for sub-fxn
  evaluate_guess <- function(guess) { # adjust brackets once done
    
    guess_validate <- FALSE # initialize validation boolean as FALSE to enter validation loop
    
    while (guess_validate == FALSE) { 
      #guess <- toupper(readline("Enter a 5-letter word, then press <enter>: "))
      
      if (nchar(guess) == 5 & guess %in% valid_list == TRUE) {
        guess_validate == TRUE  # change validation boolean, exit loop
        return(guess)
      }
      else {
        invalid_msg <- "Invalid guess. Try again."
        print(invalid_msg)
        guess <- toupper(readline("Enter a 5-letter word, then press <enter>: "))
        guess_validate == FALSE 
      }
    }
  }
  
  # print game instructions
  print(paste0(c("You have six tries to guess a random 5-letter word.",
                 "Guesses need to be valid 5-letter words.",
                 "After each guess, you will be told whether each letter your guess is either",
                 "[1] in the solution word and in the correct spot,",
                 "[2] in the solution word but in the wrong position, or",
                 "[3] not in the solution word.")))
  
  # Display unguessed letters
  guessed_letters <- list() # initialize list of guessed letters
  unguessed_letters <- setdiff(LETTERS, guessed_letters) # remove guessed letters from LETTERS vector
  print(cat("Letters left:", unguessed_letters)) # "NULL" prints at end?
  
  # prompt player for guess & read in
  guess_count <- 0 # initialize guess counter
  num_guesses <- 6
  ct<-0
  for (i in num_guesses) { # adjust brackets, might need to put this in while loop to break if WIN
    # read in and process user guess
    guess <- toupper(readline("Enter a 5-letter word, then press <enter>: "))
    guess <- evaluate_guess(guess) # send guess to validation sub-fxn (loops until valid guess)
    ct <- ct + 1 # add one to guess counter every time we have a valid guess
  #might not need the above
    guess_char <- str_split_1(guess, "") # split guess into vector of characters
    guessed_letters <- unique(c(guessed_letters, guess_char)) # add letters to list of guessed letters
  
    # split guess into character vector and create a tibble to hold results
    guess_tibble <- as_tibble_col(solution)
    guess_tibble$guess <- guess_char
      #guess_char, column_name = guess(i)) # coerce character vector into tibble 
     
    guess_tibble$ltr_match(i) <- if_else((guess_tibble$guess[i] %in% solution), TRUE, FALSE) # if guess character is in solution vector, enter boolean in new column
    guess_tibble$loc_match(i) <- if_else(guess_tibble$guess(i) == guess_tibble$solution, TRUE, FALSE) # if guess character matches the solution character, enter boolean in new column
  
  # produce result for each character 
    guess_tibble$result(i) <- case_when(
       guess_tibble$ltr_match(i) == TRUE & guess_tibble$loc_match(i) == TRUE ~ "green",
       guess_tibble$ltr_match(i) == TRUE & guess_tibble$loc_match(i) == FALSE ~ "yellow",
       guess_tibble$ltr_match(i) == FALSE & guess_tibble$loc_match(i) == FALSE ~ "red"
     )
    
    print(c("Guess", i, "of", num_guesses))
    print(guess_tibble)
}
 print(c(guess_tibble$guess(i)[1], guess_tibble$result(i)[1]))
 
```

```{r}
fruit <- c("apple", "banana", "pear", "pineapple")
str_detect(fruit, "apple", negate = TRUE)
'apple' %in% fruit
```

This function should:

1.  DONE: At the onset, tell the player the rules of the game.

2.  Display what letters the player has not yet guessed (using built-in datasets `LETTERS` or `letters`; use either the `toupper()` or `tolower()` functions to ensure consistency in letter case).

<!-- -->

3.  Prompt the player for a guess, read in their guess, and check that their guess is valid (i.e., that it contains the correct number of letters and is a word included in the "valid" word list).
4.  Compare the guess to the solution word and generate the necessary feedback,
    -   E.g., `*` for *in the word and in the correct position*, `+` for *in the word but in the wrong position*, and `-` for *not in the word*.
    -   Write a separate "helper" function, `evaluate_guess()`, called from within `play_wordle()`. Function arguments would include the player's guess and the value of the **solution** variable.
5.  Update the list of letters not yet guessed using `setdiff()` (returns difference between 2 vectors).
6.  Check if the puzzle was solved, and display whether the player WON and print out their guess and feedback history. If not, prompt the player for another guess, unless they've already hit 6 guesses.
7.  After 6 guesses, indicate that the player LOST the game and, again, print out their guess and feedback history.
